{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"apk文件结构","slug":"apk文件结构-1","date":"2024-09-10T09:11:51.000Z","updated":"2024-09-10T09:11:51.738Z","comments":true,"path":"2024/09/10/apk文件结构-1/","permalink":"http://example.com/2024/09/10/apk%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"android killer使用基础","slug":"android-killer使用基础","date":"2024-09-01T06:37:50.000Z","updated":"2024-09-10T09:58:02.370Z","comments":true,"path":"2024/09/01/android-killer使用基础/","permalink":"http://example.com/2024/09/01/android-killer%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/","excerpt":"","text":"AndroidKillerAndroidKiller是一可视化的Android反编译工具，集合了多款安卓反编译软件，只要有配置jdk环境，AndroidKiller的安装十分常规 使用基础页面![屏幕截图 174312](.&#x2F;assets&#x2F;屏幕截图 174312.png) 在左侧，工程信息位置，展示名称、包名、入口；右侧日志输出，展示 更改apk的安装包名下好一个apk安装包，这里选用土豆视频为例子 打开AndroidKiller.exe程序，把下好的apk包拉入程序中，程序会自动编译apk，中途出现分析工程提示不用管直接点击否，编译的结果如下 ![屏幕截图 174312](.&#x2F;assets&#x2F;屏幕截图 174312-1725961513461-2.png) 修改apk安装包名重新编译，具体如下图所示，所有的操作都要等待控制台的提示再判断是否做下一步操作： ![屏幕截图 174641](.&#x2F;assets&#x2F;屏幕截图 174641.png) 把编译之后的apk安装包拉到模拟器上进行安装 更换apk的图标通过MANIFEST.MF全局搜索资源，找到图标 根据找到的所有图标路径（\\AndroidKiller_v1.3.1\\projects\\土豆视频_v5.7_apkpure.com\\Project\\res），都替换成自己的图标（一个应用会拥有多个图标，这是因为一款APP在每个手机上的分辨率都是不同的，所以要多个图标来兼容手机的分辨率） 进行编译，并再次放入模拟器测试 去除广告在apk项目中打开AnddroidManifest.xml配置清单文件（首先明确一个概念，广告都是通过网络加载出来的），删除跟网络有关的标签，如下所示常见的一些网络信息标签，最后一个INTERNET保留。 解决了弹框广告，接下来是首页广告，首页广告一般是app的入口是广告活动页面，只要改成当前活动页面就可以了，而拥有了以下的两个标签和属性值才会被识别为app入口页面 123&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;","categories":[],"tags":[]},{"title":"apk文件结构","slug":"apk文件结构","date":"2024-08-29T04:50:11.000Z","updated":"2024-09-10T09:35:07.885Z","comments":true,"path":"2024/08/29/apk文件结构/","permalink":"http://example.com/2024/08/29/apk%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","excerpt":"","text":"apk文件结构APK 文件APK (Android application package) ，是应用程序的压缩包形式，将应用程序的原代码、各类资源和清单信息组合在一起，以便在设备上进行安装和运行 接下以ibilibili安装包为例观察其文件结构 下载apk文件 因为其本质上就是一个 zip压缩包。所以直接用win解压解压文件 如图，文件内部可分为 静态资源文件（assets） 库文件（lib） 签名文件（META-INF） 编译资源文件（res） 配置清单文件（AndroidManifest.xml） 核心代码文件（classes.dex） 资源映射文件（resources.arsc） 静态资源文件（assets）静态资源文件是一种未经编译的资源目录，它会被打包进 APK 文件中，在安装应用程序之后可以被访问，用于存放应用程序的原始静态文件，如音频文件、视频文件、HTML文件等 库文件（lib）用于存放动态及静态链接库的文件夹 签名文件（META-INF）其中包含MANIFEST.MF、CERT.SF和CERT.RSA文件，MANIFEST.MF文件包含了文件的SHA1摘要值，CERT.SF和CERT.RSA文件为生成的签名文件和签名块文件，应用程序管理器安装apk文件的过程中会检查证书，对比每个文件的摘要值是否匹配，防止应用程序被篡改 文件签名 加密：发送方利用接收方的公钥对要发送的明文进行加密。 解密：接收方利用自己的私钥对密文进行解密 配对：公钥和私钥配对的，用公钥加密的文件，只有对应的私钥才能解密。当然也可以反过来，用私钥加密，用对应的公钥进行解密 签名：签名是发送方为发送的文件写上一个自己的签名，所以需要使用的是自己（发送方）的私钥 验证签名： 验证签名是接收方需要确认自己接收到的密文文件是否真的是发送方发送过来的，需要确认的是中间有没有被篡改（不同于解密），验签最终是根据报文摘进行对比。 编译资源文件（res） res 是 APK文件中存放资源文件的目录，包含了应用程序使用的各种资源，如布局文件、图像文件、字符串资源等。 布局文件定义了应用程序界面的结构和组件的位置。 图像文件包含了应用程序使用的图标、背景图等图像资源。 字符串资源存储了应用程序中使用的文本字符串 配置清单文件（AndroidManifest.xml）每个应用程序都必须定义和包含的全局配置文件，它描述了应用程序的名称、版本、权限、引用的库文件等信息,其特殊点在于AndroidManifest.xml是经过压缩的，如果直接打开将看到乱码。可以通过相关工具将其解压。 classes.dexjava编译产生class文件，class文件被DX工具转换成一个dex文件，以便在Dalvik虚拟机运行，classes.dex是Java源代码编译后生成的Dalvik虚拟机字节码文件，类似于Java虚拟机使用的．class类文件，将class文件整合到一起，可以减小类文件的尺寸、IO操作，提高类的查找速度，常规来说每个APK文件只有一个classes.dex文件，但一个dex文件储存空间有限（66535），超出的会创建一个新的class.dex文件 资源映射文件（resources.arsc）一个二进制文件，包含了使用的所有资源索引信息","categories":[],"tags":[]},{"title":"android中线程间通信","slug":"android中线程间通信","date":"2024-08-01T02:54:47.000Z","updated":"2024-08-04T03:01:38.251Z","comments":true,"path":"2024/08/01/android中线程间通信/","permalink":"http://example.com/2024/08/01/android%E4%B8%AD%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"HandlerHandle是一套 Android 消息传递机制,主要用于线程间通信 handler其实就是主线程在起了一个子线程，子线程运行并生成Message，Looper获取message并传递给Handler，Handler逐个获取子线程中的Message Binder&#x2F;Socket用于进程间通信 Message ：代表一个行为或者一串动作 每一个消息在加入消息队列时,都有明确的目标Handler ThreadLocal： 线程本地存储区（Thread Local Storage，简称为TLS）ThreadLocal的作用是提供线程内的局部变量TLS,这种变量在线程的生命周期内起作用 MessageQueue ：以队列的形式对外提供插入和删除的工作 Looper ：Looper是循环的意思,它负责从消息队列中循环的取出消息然后把消息交给Handler处理 Handler ：消息的真正处理者, 具备获取消息、发送消息、处理消息、移除消息等功能 消息机制 以Handler的sendMessage方法为例，当发送一个消息后，会将此消息加入消息队列MessageQueue中。 Looper负责去遍历消息队列并且将队列中的消息分发给对应的Handler进行处理。 在Handler的handleMessage方法中处理该消息，这就完成了一个消息的发送和处理过程。 使用步骤创建 Handler 将 Handler 定义成静态的内部类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class HandlerActivity extends AppCompatActivity &#123; private Button bt_handler_send; private static class MyHandler extends Handler &#123; //弱引用持有HandlerActivity , GC 回收时会被回收掉 private WeakReference&lt;HandlerActivity&gt; weakReference; public MyHandler(HandlerActivity activity) &#123; this.weakReference = new WeakReference(activity); &#125; @Override public void handleMessage(Message msg) &#123; HandlerActivity activity = weakReference.get(); super.handleMessage(msg); if (null != activity) &#123; //执行业务逻辑 Toast.makeText(activity,&quot;handleMessage&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.HandlerActivity); //创建 Handler final MyHandler handler = new MyHandler(this); bt_handler_send = findViewById(R.id.bt_handler_send); bt_handler_send.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //使用 handler 发送空消息 handler.sendEmptyMessage(0); &#125; &#125;).start(); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; //移除所有回调及消息 myHandler.removeCallbacksAndMessages(null); super.onDestroy(); &#125;&#125; Message 获取 123Message message = myHandler.obtainMessage(); //通过 Handler 实例获取Message message1 = Message.obtain(); //通过 Message 获取Message message2 = new Message(); //直接创建新的 Message 实例 Handler 发送消息 12345public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; 使用123456789101112131415161718192021222324private static class MyHandler extends Handler &#123; private final WeakReference&lt;MainActivity&gt; mTarget; public MyHandler(MainActivity activity) &#123; mTarget = new WeakReference&lt;MainActivity&gt;(activity); &#125; @Override public void handleMessage(@NonNull Message msg) &#123; super.handleMessage(msg); HandlerActivity activity = weakReference.get(); super.handleMessage(msg); if (null != activity) &#123; //执行业务逻辑 if (msg.what == 0) &#123; Log.e(&quot;myhandler&quot;, &quot;change textview&quot;); MainActivity ma = mTarget.get(); ma.textView.setText(&quot;hahah&quot;); &#125; Toast.makeText(activity,&quot;handleMessage&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;","categories":[],"tags":[]},{"title":"android读入sd卡","slug":"android读入sd卡","date":"2024-07-29T02:41:50.000Z","updated":"2024-08-04T02:53:26.998Z","comments":true,"path":"2024/07/29/android读入sd卡/","permalink":"http://example.com/2024/07/29/android%E8%AF%BB%E5%85%A5sd%E5%8D%A1/","excerpt":"","text":"sd卡的读写操作HttpURLConnectionHttpURLConnection是基于[http协议的，支持GET、POST、PUT、DELETE等各种请求方式。如果使用HTTPS协议请求，可以使用它的子类HttpsURLConnection完成更安全的请求操作 使用步骤 创建一个URL对象： 1URL url=new URL(“接口地址”) 调用URL对象的openConnection()来获取HttpURLConnection对象实例； 1HttpURLConnection connection= (HttpURLConnection) url.openConnection(); 设置HTTP请求使用的方法：GET、POST或其他请求； 1connection.setRequestMethod(“GET”); 设置连接超时，读取超时的毫秒数，以及服务器希望得到的一些消息头； 123connection.setConnectTimeout(6*1000);connection.setReadTimeout(6 * 1000); 1 调用getInputStream()方法获得服务器返回的输入流，然后输入流进行读取了； InputStream in &#x3D; connection.getInputStream(); 最后调用disconnect()方法将HTTP连接关掉； connection.disconnect(); 使用参数setRequestProperty(key,value)【设置请求头】：设置一般请求属性。如果已存在具有该关键字的属性，则用新值改写其值。注：HTTP 要求所有能够合法拥有多个具有相同键的实例的请求属性，使用以逗号分隔的列表语法 addRequestProperty(key,value)【设置响应体】：添加由键值对指定的一般请求属性 getOutputStream【发送URL请求】：建立实际连接之后，就是发送请求，把请求参数传到服务器 使用12345678910111213141516171819202122232425262728293031323334353637383940414243public void testDoGet()&#123; String api=&quot;&quot;; HttpURLConnection connection = null; InputStream in=null; BufferedReader reader=null; try&#123; //构造一个URL对象 URL url = new URL(api); //获取URLConnection对象 connection= (HttpURLConnection) url.openConnection(); in = connection.getInputStream(); reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8)); StringBuilder sb = new StringBuilder(); String line = null; //按行读取 while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; String response= sb.toString(); System.out.println(response); &#125;catch (Exception exception)&#123; exception.printStackTrace(); &#125;finally &#123; if (connection != null) &#123; connection.disconnect(); &#125; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; AsyncTask异步操作AsyncTask&lt;Void, Void, Void&gt; 参数: 异步任务开始时 , execute() 方法传入的参数类型 , 也是 doInBackground() 方法传入的参数类型 ; 异步任务执行时 , 进度值类型 , onProgressUpdate() 方法传入的参数类型 ; 异步任务结束时 , 结果类型 , onPostExecute() 方法传入参数类型 , 或 onCancelled() 方法参数 使用步骤自定义 AsyncTask 异步任务 123456789101112131415161718192021222324252627282930package kim.hsl.aa;import android.os.AsyncTask;public class MyAsyncTask extends AsyncTask&lt;String, Integer, Boolean&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Boolean doInBackground(String... strings) &#123; return null; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; // 在 doInBackground 中调用了 publishProgress 方法, 就会回调该方法 super.onProgressUpdate(values); @Override protected void onCancelled() &#123; super.onCancelled(); &#125; @Override protected void onCancelled(Boolean aBoolean) &#123; super.onCancelled(aBoolean); &#125;&#125; 调用异步任务 12345678910111213public class MainActivity extends AppCompatActivity &#123; private MyAsyncTask mMyAsyncTask; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 创建并执行异步任务 mMyAsyncTask = new MyAsyncTask(); mMyAsyncTask.execute(); &#125;&#125; sd卡的读写在SD卡目录下创建文件 12345678File file = new File(Environment.getExternalStorageDirectory(), &quot;mysdcard.txt&quot;);Log.d(TAG, &quot;file.exists():&quot; + file.exists() + &quot; file.getAbsolutePath():&quot;+ file.getAbsolutePath());if (file.exists()) &#123; file.delete(); file.createNewFile();&#125;// Toast.makeText(MainActivity.this, &quot;SD卡目录下创建文件成功...&quot;, Toast.LENGTH_LONG).show();Log.d(TAG, &quot;SD卡目录下创建文件成功...&quot;); 在SD卡目录下的文件，写入内容 12345FileWriter fw = new FileWriter(file);fw.write(&quot;我的sdcard内容.....&quot;);fw.close();// Toast.makeText(MainActivity.this, &quot;SD卡写入内容完成...&quot;,Toast.LENGTH_LONG).show();Log.d(TAG, &quot;SD卡写入内容完成...&quot;); 读取SD卡文件里面的内容 1234FileReader fr = new FileReader(&quot;/mnt/sdcard/mysdcard.txt&quot;);BufferedReader r = new BufferedReader(fr);String result = r.readLine();Log.d(TAG, &quot;SD卡文件里面的内容:&quot; + result);","categories":[],"tags":[]},{"title":"android的四大组件","slug":"android的四大组件","date":"2024-07-21T02:12:15.000Z","updated":"2024-08-04T02:36:20.479Z","comments":true,"path":"2024/07/21/android的四大组件/","permalink":"http://example.com/2024/07/21/android%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/","excerpt":"","text":"四大组件 活动（activity），用于表现功能 服务（service），后台运行服务，不提供界面呈现 广播接受者（Broadcast Receive），勇于接收广播 内容提供者（Content Provider），支持多个应用中存储和读取数据，相当于数据库 活动定义：是用户操作的可视化界面；它为用户提供了一个完成操作指令的窗口。当我们创建完毕Activity之后，需要调用setContentView()方法来完成界面的显示 一个Activity通常就是一个单独的屏幕 可以类比为windows开发中的窗口 使用1234567public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button_1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt;&lt;/LinearLayout&gt; Actiity生命周期 在Android中会维持一个Activity Stack（Activity栈），当一个新的Activity创建时，它就会放到栈顶，这个Activity就处于运行状态。当再有一个新的Activity被创建后，会重新压人栈顶，而之前的Activity则会在这个新的Activity底下，就像枪梭压入子弹一样。而且之前的Activity就会进入后台 四种状态 a.运行中(Running&#x2F;Active):这时Activity位于栈顶，可见可交互 b.暂停(Paused):可见不可交互。当一个新的非全屏的Activity或者一个透明的Activity放置在栈顶，Activity就处于暂停状态；这个时候Activity的各种数据还被保持着；只有在系统内存在极低的状态下，系统才会自动的去销毁Activity。 c.停止(Stoped):当一个Activity被另一个Activity完全覆盖，或者点击HOME键退入了后台，这时候Activity处于停止状态。这里有些是跟暂停状态相似的：这个时候Activity的各种数据还被保持着；当系统的别的地方需要用到内容时，系统会自动的去销毁Activity。 d.销毁(Detroyed):点击返回键或者系统在内存不够用的情况下就会把Activity从栈里移除销毁，被系统回收，这时候，Activity处于销毁状态。 服务它通常用作在后台处理耗时的逻辑，与Activity一样，它存在自己的生命周期，也需要在AndroidManifest.xml配置相关信息 是Android中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还要求长期运行的任务。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行 不过需要注意的是，服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程 类似于c++中的窗口接口函数 service用于在后台 started（启动）：当应用程序组件（如activity）调用startService()方法启动服务时，服务处于started状态。 bound（绑定）：当应用程序组件调用bindService()方法绑定到服务时，服务处于bound状态。 startService()started service（启动服务）是由其他组件调用startService()方法启动的，其生命周期与启动它的组件无关，并且可以在后台无限期运行，即使启动服务的组件已经被销毁。因此，服务需要在完成任务后调用stopSelf()方法停止，或者由其他组件调用stopService()方法停止 使用123456789101112131415161718192021222324252627public class TestOneService extends Service&#123; @Override public void onCreate() &#123; Log.i(&quot;Kathy&quot;,&quot;onCreate - Thread ID = &quot; + Thread.currentThread().getId()); super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(&quot;Kathy&quot;, &quot;onStartCommand - startId = &quot; + startId + &quot;, Thread ID = &quot; + Thread.currentThread().getId()); return super.onStartCommand(intent, flags, startId); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; Log.i(&quot;Kathy&quot;, &quot;onBind - Thread ID = &quot; + Thread.currentThread().getId()); return null; &#125; @Override public void onDestroy() &#123; Log.i(&quot;Kathy&quot;, &quot;onDestroy - Thread ID = &quot; + Thread.currentThread().getId()); super.onDestroy(); &#125; 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.i(&quot;Kathy&quot;, &quot;Thread ID = &quot; + Thread.currentThread().getId()); Log.i(&quot;Kathy&quot;, &quot;before StartService&quot;); //连续启动Service Intent intentOne = new Intent(this, TestOneService.class); startService(intentOne); Intent intentTwo = new Intent(this, TestOneService.class) //停止Service Intent intentFour = new Intent(this, TestOneService.class); stopService(intentFour); //再次启动Service Intent intentFive = new Intent(this, TestOneService.class); startService(intentFive); Log.i(&quot;Kathy&quot;, &quot;after StartService&quot;); &#125; 广播接受器广播接收器是对发送出来的广播进行过滤接受并响应的一类组件。可以使用广播接收器来让应用对一个外部时间做出响应，广播接收器通过NotificationManager方法来通知用户这些事情发生了。广播接收器既可以在AndroidManifest.xml中注册，也可以在运行时的代码中使用 广播接收器没有用户界面。然而，它们可以启动一个activity或serice来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力，例如闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 注册有两种方法，分别是程序动态注册【在运行时的代码中使用Context.registerReceive（）进行注册】和AndroidManifest文件中进行静态注册 类似于windows中的消息接受处理函数 使用创建一个广播接收器BroadcastReceiver ，广播也是通过Intent来传递数据。 12345678public class MyReceiver extends BroadcastReceiver &#123; private static final String TAG = &quot;MyReceiver&quot;; @Override public void onReceive(Context context, Intent intent) &#123; String msg=intent.getStringExtra(&quot;msg&quot;); Log.e(TAG, &quot;onReceive: &quot;+msg); &#125;&#125; 清单文件注册该广播 1234567891011&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.MyApplication&quot;&gt; &lt;receiver android:name=&quot;.receiver.MyReceiver&quot; android:exported=&quot;true&quot;/&gt; &lt;/application&gt; 在其它组件里面发送广播，比如Activity里面 1234private void Acitivity()&#123; Intent intent = new Intent(this, MyReceiver.class); sendBroadcast(intent);&#125; 内容提供器给多个应用提供数据，例，APP A的数据库内容不可被APP B进行读取的，此时，一个内容提供者，可以将APP A中的数据信息提供给APP B 获取通讯录中的联系人，申请好友。 获取其他软件搜索记录，大数据计算，进行产品推送。 预约直播，将预约信息写入手机备忘 这一组件暂时不做过多记录","categories":[],"tags":[]},{"title":"java输入输出","slug":"java输入输出","date":"2024-07-18T12:25:30.000Z","updated":"2024-07-18T12:55:14.622Z","comments":true,"path":"2024/07/18/java输入输出/","permalink":"http://example.com/2024/07/18/java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"","text":"输入输出流 输入流 输出流 字节流 InputStream OutputStream 字符流 Reader Writer 输入到控制台语法 12345678public class test &#123; public static void main(String[] args) &#123; System.out.println(msg);//输出一个字符串并换行 System.out.print(msg);//输出一个字符串不换行 System.out.printf(format,msg);//格式化输出 &#125;&#125; println输出的内容自带\\n，print不带\\n。 printf的格式化输出方式和C语言中的printf基本是一致的。 类似c语言的占位输出符 转换符 类型 举例 d 十进制整数 （“%d”,100） 100 x 十六进制整数 （”%x“,100） 64 o 八进制整数 （”%o“,100） 144 f 定点浮点数 （”%f“,100f） 100.000000 e 指数浮点数 （”%e“,100f） 1.000000e+02 g 通用浮点数 （”%g“,100） 100.000 a 十六进制浮点数 （”%a“,100） 0x1.9p6 s 字符串 （”%s“,“100”） 100 c 字符 （”%c“,‘1’） 1 b 布尔值 （”%b“,100） true % 百分号 （”%。2f%%“,2&#x2F;7f） 0.29% 从键盘输入1234567891011import java.util.Scanner;//导入util包public class test &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int num = scanner.nextInt();//从键盘输入一个数字 System.out.println(num);//输出该数字 sc.close();//注意，要记得调用关闭方法 &#125;&#125; OutputStream与InputStream123456789101112131415161718192021222324import java.io.*; public class InputStreamOutputStreamExample &#123; public static void main(String[] args) &#123; try &#123; // 创建一个文件输入流对象，用于读取文件内容 FileInputStream fis = new FileInputStream(&quot;input.txt&quot;); // 创建一个文件输出流对象，用于将数据写入文件 FileOutputStream fos = new FileOutputStream(&quot;output.txt&quot;); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = fis.read(buffer)) != -1) &#123; fos.write(buffer, 0, bytesRead); &#125; fis.close(); fos.close(); System.out.println(&quot;文件复制成功！&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; read方法read()从输入流中读取数据的下一个字节到程序内部中，返回值为字符的ASCII值，否则为-1 read(byte [] b )从输入流中读取的一定数量字节数,并将它们存储到缓冲区数组b中，返回值为实际读取的字节数 read( byte [] b , int off , int len)读取 len字节的数据从输入流到一个字节数组，返回实际读取的字节数 12345678910111213141516171819202122232425262728293031323334package com.yiibai;import java.io.FileInputStream;import java.io.InputStream;public class InputStreamDemo &#123; public static void main(String[] args) throws Exception &#123; InputStream is = null; byte[] buffer=new byte[5]; char c; try&#123; // 文本内容为 ABCDE is = new FileInputStream(&quot;C://test.txt&quot;); // 这个2指的是数据偏移 不是流偏移 is.read(buffer, 2, 3); // 循环字节数据 for(byte b:buffer)&#123; if(b==0) // 偏移了2个单位数组默认值为0,所以前面2个单位是没有的 c=&#x27;-&#x27;; else c=(char)b; System.out.print(c); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; if(is!=null) is.close(); &#125; &#125;&#125; write方法 write(int c)：写入数字，利用 ASCII 码表 或者 Unicode 表转化 write(String str)：写入字符串 write(char[] cbuf)：写入字符数组 write(String str, int off, int len)：写入字符串的一部分 write(char[] cbuf,int off,int len)：写入字符数组的一部分","categories":[],"tags":[]},{"title":"java的多线程","slug":"java的多线程","date":"2024-07-18T02:50:51.000Z","updated":"2024-08-01T02:56:00.535Z","comments":true,"path":"2024/07/18/java的多线程/","permalink":"http://example.com/2024/07/18/java%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"多线程概述多线程是实现并发机制的一种有效手段。进程和线程一样，都是实现并发的一个基本单位。线程是比进程更小的执行单位，线程是在进程的基础上进行的进一步划分。所谓多线程是指一个进程在执行过程中可以产生多个线程，这些线程可以同时存在、同时运行，一个进程可能包含了多个同时执行的线程。 进程与线程进程：正在运行的应用程序：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，即每个进程都有着自己的堆、栈等且是互不共享的。 线程：进程中的一个执行路径（一段程序从执行到结束的整个过程），共享一个内存空间，线程之间可以自由切换，并发执行，一个进程最少有一个线程线程实际上是在进程的基础上进一步划分的，一个进程执行后，里面的若干执行路径又可以划分为若干个线程 线程调度分时调度所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 CPU使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核心而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉很快，看上去就是在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 多线程的实现方式继承Thread类 创建一个自定义类并继承Thread类； 重写run()方法，创建新的执行任务（通过thread对象的start()方法启动任务，一般不直接调用run()方法） 创建自定义类对象实例，调用start()，让线程执行 1234567891011121314151617181920//MyThread.javapublic class MyThread extends Thread&#123; @Override public void run() &#123; //run()方法就是线程要执行的任务的方法 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;MyThread&quot; + i); &#125; &#125;&#125;//ThreadTest.javapublic class ThreadTest &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start(); //启动线程任务 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(&quot;MainThread&quot; + i); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"java异常抛出实例","slug":"java异常抛出实例","date":"2024-07-11T09:13:23.000Z","updated":"2024-07-11T09:21:42.966Z","comments":true,"path":"2024/07/11/java异常抛出实例/","permalink":"http://example.com/2024/07/11/java%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"实例自定义异常 12345public class my_exception extends Exception &#123; public void pick()&#123; System.out.println(&quot;Error: 越界&quot;); &#125;&#125; 抛出异常类及方法 12345678910111213141516171819public class pointjd &#123; private int x=0; public void move(char s)throws my_exception&#123; if(s == &#x27;a&#x27;) &#123; x-=1; if(x&lt;=-5) throw new my_exception(); &#125; else if(s ==&#x27;d&#x27;) &#123; x+=1; if(x&gt;=5) throw new my_exception(); &#125; else System.out.println(&quot;warning!&quot;); &#125;&#125; 主函数 1234567891011121314151617181920212223//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; pointjd p = new pointjd(); Scanner scanner = new Scanner(System.in); for(int i= 0 ;i&lt;9;i++)&#123; char mv; String MV; MV = scanner.next(); mv=MV.charAt(0); try&#123; p.move(mv); &#125; catch(my_exception e)&#123; e.printStackTrace(); e.pick(); &#125; &#125; System.out.println(&quot;over&quot;); &#125;&#125; 创建自定义异常类： 声明一个继承自Exception类或RuntimeException类的类。 根据需要添加构造方法和其他方法。例如，你可以添加一个带有错误消息的构造方法，以便在抛出异常时提供有关异常的详细信息。 在方法适当的位置生成自定义异常的实例，并用throw语句抛出： 当你的代码遇到特定的错误情况时，你可以创建一个自定义异常类的实例，并使用throw语句将其抛出。这将导致程序的控制流跳转到最近的catch块（如果存在的话）。 在方法的声明部分用throws语句声明可能抛出的异常： 如果你的方法可能会抛出异常（无论是自定义异常还是预定义异常），你都应该在方法的声明部分使用throws语句来声明它。这将告诉调用该方法的代码需要处理这个异常，或者它也可以继续向上抛出这个异常。 捕获和处理异常： 在你的代码中，你可以使用try-catch块来捕获和处理异常。在try块中，你放置可能会抛出异常的代码。在catch块中，你处理这些异常。你可以根据异常的类型来决定如何处理它们。例如，如果你捕获到的是你的自定义异常，你可以根据异常中包含的信息来采取适当的行动。 异常的解决方式异常声明throws​ 当方法中抛出编译时异常，用户不想处理该异常，此时就可以借助throws将异常抛给方法的调用者来处理。即当前方法不处理异常，提醒方法的调用者处理异常。 12345678910111213修饰符 返回值类型 方法名(参数列表) throws 异常类型1，异常类型2...&#123; &#125;public static void divide(int a, int b) throws ArithmeticException &#123; if (b == 0) &#123; throw new ArithmeticException(&quot;除数不能为0&quot;); &#125; int result = a / b; System.out.println(&quot;结果：&quot; + result);&#125; throws必须跟在方法的参数列表之后 声明的异常必须是 Exception 或者 Exception 的子类 方法内部如果抛出了多个异常，throws之后必须跟多个异常类型，之间用逗号隔开，如果抛出多个异常类型具有父子关系，直接声明父类即可。 调用声明抛出异常的方法时，调用者必须对该异常进行处理，或者继续使用throws抛出 try - catch - finally语句异常可以通过try-catch-finally语句块来进行处理。由于throws对异常并没有真正处理，而是将异常报告给抛出异常方法的调用者，由调用者处理。如果真正要对异常进行处理，就需要try-catch 123456789try &#123; // 可能抛出异常的代码&#125; catch (ExceptionType1 e1) &#123; // 处理异常类型1的情况&#125; catch (ExceptionType2 e2) &#123; // 处理异常类型2的情况&#125; finally &#123; // 可选的finally语句块，用于执行清理操作&#125; finally语句块是可选的，用于执行清理操作，无论是否发生异常都会执行。finally语句块通常用于释放资源或执行必要的收尾工作，例如关闭文件或数据库连接。 try块内抛出异常位置之后的代码将不会被执行 如果抛出异常类型与catch时异常类型不匹配，即异常不会被成功捕获，也就不会被处理，继续往外抛，直到JVM收到后中断程序—-异常是按照类型来捕获的** try中可能会抛出多个不同的异常对象，则必须用多个catch来捕获—-即多种异常，多次捕获 如果多个异常的处理方式是完全相同，我们可以使用“ | ”隔开 如果异常之间具有父子关系，一定是子类异常在前catch，父类异常在后catch，否则语法错误 异常分类检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这些异常在编译时强制要求程序员处理。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常（非检查性异常）：这些异常在编译时不强制要求处理，通常是由程序中的错误引起的，例如 NullPointerException、ArrayIndexOutOfBoundsException 等，这类异常可以选择处理，但并非强制要求","categories":[],"tags":[]}],"categories":[],"tags":[]}