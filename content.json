{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"java异常抛出实例","slug":"java异常抛出实例","date":"2024-07-11T09:13:23.000Z","updated":"2024-07-11T09:21:42.966Z","comments":true,"path":"2024/07/11/java异常抛出实例/","permalink":"http://example.com/2024/07/11/java%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"实例自定义异常 12345public class my_exception extends Exception &#123; public void pick()&#123; System.out.println(&quot;Error: 越界&quot;); &#125;&#125; 抛出异常类及方法 12345678910111213141516171819public class pointjd &#123; private int x=0; public void move(char s)throws my_exception&#123; if(s == &#x27;a&#x27;) &#123; x-=1; if(x&lt;=-5) throw new my_exception(); &#125; else if(s ==&#x27;d&#x27;) &#123; x+=1; if(x&gt;=5) throw new my_exception(); &#125; else System.out.println(&quot;warning!&quot;); &#125;&#125; 主函数 1234567891011121314151617181920212223//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; pointjd p = new pointjd(); Scanner scanner = new Scanner(System.in); for(int i= 0 ;i&lt;9;i++)&#123; char mv; String MV; MV = scanner.next(); mv=MV.charAt(0); try&#123; p.move(mv); &#125; catch(my_exception e)&#123; e.printStackTrace(); e.pick(); &#125; &#125; System.out.println(&quot;over&quot;); &#125;&#125; 创建自定义异常类： 声明一个继承自Exception类或RuntimeException类的类。 根据需要添加构造方法和其他方法。例如，你可以添加一个带有错误消息的构造方法，以便在抛出异常时提供有关异常的详细信息。 在方法适当的位置生成自定义异常的实例，并用throw语句抛出： 当你的代码遇到特定的错误情况时，你可以创建一个自定义异常类的实例，并使用throw语句将其抛出。这将导致程序的控制流跳转到最近的catch块（如果存在的话）。 在方法的声明部分用throws语句声明可能抛出的异常： 如果你的方法可能会抛出异常（无论是自定义异常还是预定义异常），你都应该在方法的声明部分使用throws语句来声明它。这将告诉调用该方法的代码需要处理这个异常，或者它也可以继续向上抛出这个异常。 捕获和处理异常： 在你的代码中，你可以使用try-catch块来捕获和处理异常。在try块中，你放置可能会抛出异常的代码。在catch块中，你处理这些异常。你可以根据异常的类型来决定如何处理它们。例如，如果你捕获到的是你的自定义异常，你可以根据异常中包含的信息来采取适当的行动。 异常的解决方式异常声明throws​ 当方法中抛出编译时异常，用户不想处理该异常，此时就可以借助throws将异常抛给方法的调用者来处理。即当前方法不处理异常，提醒方法的调用者处理异常。 12345678910111213修饰符 返回值类型 方法名(参数列表) throws 异常类型1，异常类型2...&#123; &#125;public static void divide(int a, int b) throws ArithmeticException &#123; if (b == 0) &#123; throw new ArithmeticException(&quot;除数不能为0&quot;); &#125; int result = a / b; System.out.println(&quot;结果：&quot; + result);&#125; throws必须跟在方法的参数列表之后 声明的异常必须是 Exception 或者 Exception 的子类 方法内部如果抛出了多个异常，throws之后必须跟多个异常类型，之间用逗号隔开，如果抛出多个异常类型具有父子关系，直接声明父类即可。 调用声明抛出异常的方法时，调用者必须对该异常进行处理，或者继续使用throws抛出 try - catch - finally语句异常可以通过try-catch-finally语句块来进行处理。由于throws对异常并没有真正处理，而是将异常报告给抛出异常方法的调用者，由调用者处理。如果真正要对异常进行处理，就需要try-catch 123456789try &#123; // 可能抛出异常的代码&#125; catch (ExceptionType1 e1) &#123; // 处理异常类型1的情况&#125; catch (ExceptionType2 e2) &#123; // 处理异常类型2的情况&#125; finally &#123; // 可选的finally语句块，用于执行清理操作&#125; finally语句块是可选的，用于执行清理操作，无论是否发生异常都会执行。finally语句块通常用于释放资源或执行必要的收尾工作，例如关闭文件或数据库连接。 try块内抛出异常位置之后的代码将不会被执行 如果抛出异常类型与catch时异常类型不匹配，即异常不会被成功捕获，也就不会被处理，继续往外抛，直到JVM收到后中断程序—-异常是按照类型来捕获的** try中可能会抛出多个不同的异常对象，则必须用多个catch来捕获—-即多种异常，多次捕获 如果多个异常的处理方式是完全相同，我们可以使用“ | ”隔开 如果异常之间具有父子关系，一定是子类异常在前catch，父类异常在后catch，否则语法错误 异常分类检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这些异常在编译时强制要求程序员处理。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常（非检查性异常）：这些异常在编译时不强制要求处理，通常是由程序中的错误引起的，例如 NullPointerException、ArrayIndexOutOfBoundsException 等，这类异常可以选择处理，但并非强制要求","categories":[],"tags":[]}],"categories":[],"tags":[]}