{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2024-07-07T11:46:56.501Z","updated":"2024-07-07T11:46:56.501Z","comments":true,"path":"2024/07/07/hello-world/","permalink":"http://example.com/2024/07/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"","slug":"5.1","date":"2024-05-02T01:19:54.140Z","updated":"2024-05-02T01:20:41.797Z","comments":true,"path":"2024/05/02/5.1/","permalink":"http://example.com/2024/05/02/5.1/","excerpt":"","text":"buu [GWCTF 2019]xxor![屏幕截图 2024-04-24 192519](.&#x2F;assets&#x2F;屏幕截图 2024-04-24 192519.png) main函数之前有运行其他函数，但没什么影响 ![屏幕截图 2024-04-24 192612](.&#x2F;assets&#x2F;屏幕截图 2024-04-24 192612.png) a2是一个指针，v6每次给它一个地址，然后由a2接收输入的值，总共输入6个值每个值32占位空间，v6的值最后给了v7作为判断的一段 ![屏幕截图 2024-04-24 192941](.&#x2F;assets&#x2F;屏幕截图 2024-04-24 192941.png) tea加密，密钥是[2,2,3,4] ![屏幕截图 2024-04-24 193402](.&#x2F;assets&#x2F;屏幕截图 2024-04-24 193402.png) 最后的判断程序，a1数组的值应该即为程序加密过的密文，这里为了求解a1，采用python下的一个模块z3约束器 z3用法1.声明变量 z3中有3中类型的变量，分别是整型(Int),实型(Real)和向量(BitVec) Int-整数型 1234from z3 import *a = Int(&#x27;a&#x27;)#声明单个整型变量a,b = Ints(&#x27;a b&#x27;)#声明多个整型变量 Real-实数型 1234from z3 import *a = Real(&#x27;a&#x27;)#声明单个实型变量a,b = Reals(&#x27;a b&#x27;)#声明多个实型变量 计算 1234from z3 import *a,b = Ints(&#x27;a b&#x27;)solve(a&gt;3,b&lt;8,2*a+b==16)#结果 [a = 5, b = 6 在解决问题是很多情况下是有多个约束条件的。这个时候可以先生成一个求解器对象(Solver())，然后就可以方便的向其中添加更多的约束条件。 123456789101112from z3 import *a,b = Ints(&#x27;a b&#x27;)solver = Solver()#创建一个求解器对象solver.add(a+b==10)#用add方法添加约束条件solver.add(a-b==6)if solver.check() == sat: #check()方法用来判断是否有解，sat(satisify)表示满足有解 ans = solver.model() #model()方法得到解 print(ans) #也可以用变量名作为下标得到解 print(ans[a])else: print(&quot;no ans!&quot;) 更多用法参考官方文档： https://rise4fun.com/z3/tutorialcontent/guide 回归题目z3脚本如下 12345678910111213from z3 import *a1,a2,a3,a4,a5,a6=Ints(&#x27;a1 a2 a3 a4 a5 a6&#x27;)s = Solver()s.add(a3-a4==2225223423)s.add(a4+a5==4201428739)s.add(a3-a5==1121399208)s.add(a1==-548868226)s.add(a6==-2064448480)s.add(a2==550153460)if(s.check()==sat): print(s.model())else: print(&quot;false&quot;) 得到 1a[6]=[-548868226,550153460,3774025685,1548802262,2652626477,-2064448480] 随后进行tea加密的逆运算即可 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std; int main()&#123; __int64 a[6] = &#123; 3746099070, 550153460, 3774025685, 1548802262, 2652626477, 2230518816 &#125;; int a2[4] = &#123; 2,2,3,4 &#125;; int v3, v4; int v5; for (int j = 0; j &lt;= 4; j += 2) &#123; v3 = a[j]; v4 = a[j + 1]; v5 = 1166789954*0x40; for (int i = 0; i &lt;= 0x3F; ++i) &#123; v4 -= (v3 + v5 + 20) ^ ((v3 &lt;&lt; 6) + a2[2]) ^ ((v3 &gt;&gt; 9) + a2[3]) ^ 0x10; v3 -= (v4 + v5 + 11) ^ ((v4 &lt;&lt; 6) + *a2) ^ ((v4 &gt;&gt; 9) + a2[1]) ^ 0x20; v5 -= 1166789954; &#125; a[j] = v3; a[j + 1] = v4; &#125; for (int i = 0; i &lt; 6; ++i) &#123; cout &lt;&lt; *((char*)&amp;a[i] + 2) &lt;&lt; *((char*)&amp;a[i] + 1) &lt;&lt; * ((char*)&amp;a[i]);//整形数据转换字符串类型输出，注意计算机小端排序，因此这里采用对一个整型数据作逆序 &#125; system(&quot;PAUSE&quot;); return 0;&#125; flag{re_is_great!} [WUSTCTF2020]level3查壳,elf，拉入linux，切换到远程调试， ida打开，查看源码 ![屏幕截图 2024-04-17 192832](.&#x2F;assets&#x2F;屏幕截图 2024-04-17 192832.png) 明显的base64加密，但直接拉入base64解密工具后得到错误结果，分析原因，可能有二 一是明文有过改动 二是子码表被更改 但main函数中不存在上述两个过程，因此查main的交叉引用，查看是否有函数先于main函数运行， ![屏幕截图 2024-04-17 193241](.&#x2F;assets&#x2F;屏幕截图 2024-04-17 193241.png) 找到main函数的主调函数，但是仍找到需要的过程转换思路，直接从被修改的值下手 查base64子码表的交叉引用，发现一个很显眼的函数![屏幕截图 2024-04-17 193408](.&#x2F;assets&#x2F;屏幕截图 2024-04-17 193408.png) 果然在这函数中字码表被修改 因此我们选择运行，在进入main函数后再去找已经修改过的子码表 ![屏幕截图 2024-04-17 193704](.&#x2F;assets&#x2F;屏幕截图 2024-04-17 193704.png) 找到新的子码表后，在使用相应工具即可 特殊的base64用Exeinfo PE 查壳 发现未加壳。 ![屏幕截图 2024-05-02 083621](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 083621.png) 运行程序输入任意字符后程序直接退出，推断可能是判断输入的Base64是否和某特定值相同，不相同程序就退出。 使用IDA打开该程序文件，找到main函数，使用F5快捷键反编译生成伪代码。 ![屏幕截图 2024-05-02 083818](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 083818.png) 发现第14行的”rightFlag“：mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI&#x3D;&#x3D;，像是经Base64加密后的字符串。 尝试base64解码，得到结果： 这并非可识别的flag。![屏幕截图 2024-05-02 083859](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 083859.png) 重新查看main函数的行为，发现函数base64Encode对result的数据进行了加密。进入base64Encode函数，发现自定义加密字典：AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0987654321&#x2F;+ 为换表base64加密 使用该字典对前面的字符串解码，得到： ![屏幕截图 2024-05-02 084028](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 084028.png) Universe_final_answerida f5找到主函数，发现关键函数sub_860()： ![屏幕截图 2024-05-02 084913](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 084913.png) 其实本身逻辑是比较简单的，问题就在于怎么运算： 所以再次用到z3约束器 1234567891011121314151617181920212223242526272829303132from z3 import * #s = Solver()v1 = Int(&#x27;v1&#x27;)v2 = Int(&#x27;v2&#x27;)v3 = Int(&#x27;v3&#x27;)v4 = Int(&#x27;v4&#x27;)v5 = Int(&#x27;v5&#x27;)v6 = Int(&#x27;v6&#x27;)v7 = Int(&#x27;v7&#x27;)v8 = Int(&#x27;v8&#x27;)v9 = Int(&#x27;v9&#x27;)v11 = Int(&#x27;v11&#x27;) s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)s.add( 30 * v11 + -70 * v9 + -122 * v6 + -81 * v7 + -66 * v5 + -115 * v4 + -41 * v3 + -86 * v1 - 15 * v2 - 30 * v8 == -54400)s.add(-103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - ( v6 * 64) - 120 * v9 == -10283)s.add(71 * v6 + (v7 * 128) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855)s.add(5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944)s.add(-54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222)s.add(-83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258)s.add(81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559)s.add(101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308)s.add(99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697) if s.check() == sat: result = s.model() print(result) 按照相应的顺序转成字符串（根据ida内函数逻辑可以知道，v2和v1互换，v7和v6互换） 得到内容：F0uRTy_7w@，将其输入到输入到程序中，即可get flag！ flag{F0uRTy_7w@_42} MFC1在VS一开始安装的时候,没有勾选MFC模块的话,是无法快速构成MFC应用的.1.观察VS2019中有无MFC模块若没有下载安装MFC模块2.创建一个基于对话框的MFC应用程序MFC是一个框架，新建一个MFC的工程，开发环境会自动产生许多文件，即使不添加一行代码，也可以编译运行，生成一个默认的有界面的软件。![屏幕截图 2024-05-02 085958](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 085958.png) 3.MFC框架结构了解生成框架代码，能更好的在MFC在框架上开发软件。 课程介绍 ![屏幕截图 2024-05-02 085929](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 085929.png) ![屏幕截图 2024-05-02 085940](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 085940.png) MFC提供三种模板 单文档 多文档 对话框 ![屏幕截图 2024-05-02 090037](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 090037.png) ![屏幕截图 2024-05-02 090023](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 090023.png) 模板中类继承层次： 单文档类的继承层次 ![屏幕截图 2024-04-29 210704](.&#x2F;assets&#x2F;屏幕截图 2024-04-29 210704-1714612163409-24.png) 不同类的作用： 父类可以实现的功能 子类也可以实现 ![屏幕截图 2024-04-29 210708](.&#x2F;assets&#x2F;屏幕截图 2024-04-29 210704-1714612163409-25.png) 在官网中可以看到层次结构图 ![屏幕截图 2024-04-29 210711](.&#x2F;assets&#x2F;屏幕截图 2024-04-29 210704-1714612163409-26.png) F10找到winmain ![屏幕截图 2024-04-29 210716](.&#x2F;assets&#x2F;屏幕截图 2024-04-29 210704-1714612163409-27.png) 选中SingleDoc，选择项目的属性 ![屏幕截图 2024-04-29 210720](.&#x2F;assets&#x2F;屏幕截图 2024-04-29 210704-1714612163409-28.png) 选择高级，MFC的使用，在静态库中使用MFC 以下了解与网络 应用程序类MFC定义了一个应用程序基类CWinApp，所有基于MFC的应用程序都会继承这个类。DemoCV项目也不例外，此时的应用程序类是CDemoCVOneApp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// DemoCV.cpp: 定义应用程序的类行为。//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;DemoCV.h&quot;#include &quot;DemoCVDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CDemoCVAppBEGIN_MESSAGE_MAP(CDemoCVApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CDemoCVApp 构造CDemoCVApp::CDemoCVApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的 CDemoCVApp 对象CDemoCVApp theApp;// CDemoCVApp 初始化BOOL CDemoCVApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CDemoCVDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; 对话框类MFC主对话框类（主对话框是指与项目名称一致的那个类对应的对话框，下同）CDemoCVDlg继承CDialogEx类，CDialogEx又继承CDialog类，这个可以通过类转到定义查看，对话框类负责与用户交互，处理用户消息，接受用户输入。类的定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// DemoCVDlg.cpp: 实现文件//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;DemoCV.h&quot;#include &quot;DemoCVDlg.h&quot;#include &quot;afxdialogex.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_ABOUTBOX &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// CDemoCVDlg 对话框CDemoCVDlg::CDemoCVDlg(CWnd* pParent /*=nullptr*/) : CDialogEx(IDD_DEMOCV_DIALOG, pParent)&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CDemoCVDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CDemoCVDlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON()END_MESSAGE_MAP()// CDemoCVDlg 消息处理程序BOOL CDemoCVDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != nullptr) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void CDemoCVDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;void CDemoCVDlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0) int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CDemoCVDlg::OnQueryDragIcon()&#123; return static_cast&lt;HCURSOR&gt;(m_hIcon);&#125; 2![屏幕截图 2024-05-02 091700](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 091700.png) ![屏幕截图 2024-05-02 091711](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 091711.png) ![屏幕截图 2024-05-02 091719](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 091719.png) ![屏幕截图 2024-05-02 091733](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 091733.png) ![屏幕截图 2024-05-02 091748](.&#x2F;assets&#x2F;屏幕截图 2024-05-02 091748.png) 实例：MFC对话框控件和背景图片自适应窗口最大化和拉伸缩放的实现 假设创建的对话框的类名是CMyDlg，具体过程如下： 步骤一：把easysize.h拷贝到CMyDlg项目文件夹中，同时在CMyDlg的.h文件和.cpp文件中加入#include”easysize.h”； or（#include EasySize.h to your stdafx.h (or put it in your include directory and #include &lt;EasySize.h&gt; , which I recommend) 步骤二：在CMyDlg类的h文件中，加入DECLARE_EASYSIZE，注意结尾处不要加“；”。 1234567891011class CMyDlg : public CDialog&#123; DECLARE_EASYSIZE// Construction…&#125; 步骤三：在CMyDlg类的OnInitDialog()函数的结尾处加入INIT_EASYSIZE, 注意此处结尾处要加“；”。 12345678910111213BOOL CMyDlg::OnInitDialog()&#123; …// TODO: Add extra initialization here​ INIT_EASYSIZE;​ return TRUE; // return TRUE unless you set the focus to a control&#125; 步骤四：增加WM_SIZE消息响应函数OnSize()，在函数中加入UPDATE_EASYSIZE，注意此处结尾处要加“；”。 123456789101112131415161718192021void CMyDlg::OnSize(UINT nType, int cx, int cy)&#123; CDialog::OnSize(nType, cx, cy); // TODO: Add your message handler code here UPDATE_EASYSIZE;&#125; OnSizing(）函数中可以设置窗口最小尺寸void CchinaDiankeSarDisPlayImagDlg::OnSizing(UINT fwSide, LPRECT pRect)&#123;CDialogEx::OnSizing(fwSide, pRect);// TODO: 在此处添加消息处理程序代码EASYSIZE_MINSIZE(587, 406, fwSide, pRect);&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}